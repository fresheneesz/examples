"use strict;"

require('sugarwrap')
var utils = require('utils')
var db = require("database").mongo
var proto = require("bt/proto")

var Logger = require("logger")
var logger; // undefined for now (to avoid a circular dependency logger has on this module)
function getLogger() {
    if(!logger)
        logger = Logger()
    return logger
}


// todo -  maybe incorporate something where objects know about which objects inside represent objects from other collections
    // so you could do stuff like automatically box and unbox objects when you save an object
    // then again, since in mongo you can have nested objects, this might not be that necessary

// abstract - requires the following members:
    // 'collection' - the collection of the object
module.exports = proto(Object.extend(), function() {
    this.make = function(members) {
        if(!members)
            return undefined

        utils.merge(this, members)
        return this
    }

    this.makeById = function(id, members) {
        if(!id) return undefined
        if(!members) members = {}
        members._id = this.id(id)
        return this.self(members)
    }

    // static methods (by intention)

    // get by id
    this.get = function(id) {
        return this.findOne({_id:id})
    }

    this.findOne = function(query) {
        var userData = utils.futureWrap(this.read(), 'findOne')(query)
        return this.self(userData.wait())
    }.future()

    this.find = function(query) {
        var userData = utils.futureWrap(this.read().find(query), 'toArray')()
        return userData.wait().map(this.self)
    }.future()

    // instance methods

    this.insert = function(journal) {
        saveOrInsert(this, 'insert', journal).detach()     // detatch so that the future will throw a visible exception if one happens and the future isn't waited on (which it won't be)
    }

    this.save = function(journal) {
        saveOrInsert(this, 'save', journal).detach()
    }

    // protected

    this.write = function() {
        return db.write.collection(this.collection)
    }
    this.read = function() {
        return db.read.collection(this.collection)
    }

    this.id = function(id) {
        return db.read.ObjectID(id)
    }

    // private

    // returns a future
    function saveOrInsert(me, type, journal) {
        var propertiesToPersist = {}
        me.each(function(v, k) {
            propertiesToPersist[k] = v
        })

        if(journal === undefined)
            journal = true

        try {
            return utils.futureWrap(me.write(), type)(propertiesToPersist, {journal: journal})
        } catch(e) {    // catching and rethrowing because mongoskin seems to block the full long-trace
            throw new Error("Couldn't "+type+" because: "+ e.message + ": "+e.stack+"\n -----Caused by:------ ")
        }
    }
})