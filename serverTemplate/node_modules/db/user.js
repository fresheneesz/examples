var Future = require("fibers/future")
var Fiber = require("fibers");
var moment = require("moment")

var utils = require("utils")
var sec = require("securityutil")
var proto = require("proto")
var MongoObject = require('MongoObject')

module.exports = proto(MongoObject, function() {

    this.collection = 'user'

    this.make = function() {
        var args = utils.trimArgs(arguments)

        // properties
        if(args.length === 1) {
            return MongoObject.make.apply(this, arguments) // "superclass" constructor call

        // sn, password
        } else if(args.length > 1) {
            var screenname = args[0]
            var password = args[1]

            return MongoObject.make.call(this,{
                sn: screenname,
                phash: sec.passwordHash(password)
            })
        }
    }

    // static methods

    this.login = function(screenname, password) {
        var user = this.findOne({sn:screenname}).wait()
        if(!user)
            return {result: 'noUser'}
        if(!user.validPassword(password))
            return {result: 'passwordMismatch'}

        return {result: 'success', user: user}
    }

	this.createGhostUser = function(creator, name) {
        var user = this.self({
            _id: this.id(),
        	owner: creator._id,
        	name: name
        })

		if(utils.check(name).isEmail())
            user.email = name

        user.insert()
        return user
	}

    // returns undefined if token hash doesn't validate
    this.crackToken = function(rawToken) {
        var token = JSON.parse(rawToken)
        if(sec.validateAuthHash(token.data, token.hash)) {
            var data = JSON.parse(token.data)
            var isntExpiredYet = moment().isAfter( moment(data.expires) )
            if(isntExpiredYet) {
                return data
            }
        }
    }

    this.blacklistToken = function(rawToken) {
        var token = JSON.parse(rawToken)
        sec.blacklistAuthHash(token.hash)
    }

    // instance methods

    this.validPassword = function(password) {
        return sec.verifyPassword(password, this.phash).wait()
    }

    this.sessionToken = function() {
        var data = JSON.stringify({id: this._id, expires: moment().add('days', 1).unix()})
        return JSON.stringify({hash: sec.createAuthHash(data), data: data})
    }

	this.signUp = function(screenname,password,password2) {
		var user = this.findOne({sn:screenname}).wait();
		if (user) {
				return {result: 'userExists'};	
		}
		if (password != password2) {
			return {result: 'passwordMismatch'};
		}

		var fiber = Fiber.current;
		this.save({sn:screenname, phash: sec.passwordHash(password)},{w:0},function(err,saved) {
			if (err || !saved) {
				fiber.run(false);
			}
			fiber.run(true);
		});
		var result = fiber.yield();
		if (!result) {
				return {result: 'failure'};
		}

		return {result: 'success'};

	}
})

/*

class User extends DataObject {

    static $tableName = 'user'

    const noUser = 0
    const passwordMismatch = 1
    const tooManyUsers = 2 // this should never hasec.salt().wait()ppen
    const userAlreadyExists = 3
    const userAlreadyExistsAndPasswordMatches = 4
    const userNotSignedIn = 5 // obviously this means the user needed to have been signed in already

    static function validName($name) {
        //if($name === '') return false // todo: replace this
        // else
        return true
    }

    static function validPassword($password) {
        //if(strlen($password) < 4) return false // todo: replace this
        // else
        return true
    }



    // returns a user object
    // throws exception if
    // * The user already exists
    static function signUp($username, $password) {
        self::$logger->info("Trying to sign up $username with password $password")

        $user = self::getUserByUsername($username)
        if($user !== null) {
            if($user->passwordHash === self::hashPassword($password, $user->nonce)) {
				throw new resultCept(self::userAlreadyExistsAndPasswordMatches, $user)
			} else {
				throw new resultCept(self::userAlreadyExists)
			}
        }

		$newNonce = self::createNonce()
        $user = new User(array(
        	'username'=>$username,
        	'passwordHash'=>self::hashPassword($password, $newNonce),
        	'nonce'=>$newNonce,
        	'created'=>self::dbDate(time())
		))
        $user->insert()
        return $user
    }

	static function getUser($id) {
        $users = self::select('id="'.Database::clean($id).'"')
        return self::onlyOneUser($users, "Got more than one user for an id")
	}

    // private methods

	private static function createNonce() {
		return rand()
	}
	private static function hashPassword($password, $nonce) {
		return md5($password.$nonce.self::salt)	// putting salt at end because it is constant (not sure if that increases security, but probably does)
	}

    private static function getUserByUsername($username) {
        $users = self::select('username="'.Database::clean($username).'"')
        return self::onlyOneUser($users, "Got more than one user for a username")
    }

    private static function onlyOneUser($list, $errorMsg) {
        $resultCount = count($list)
        if($resultCount == 0) {
            return null
        } else if($resultCount > 1) {
            throw new cept($errorMsg)
        }

        return $list[0]   // return the only result
	}
}
User::init()
                */
