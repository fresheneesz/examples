var keys = ['awef93f822a3']
var keygrip = require("keygrip")(keys)
//var crypto = require("bt/crypto")
var Future = require("fibers/future")
var utils = require("utils")

var tokenBlacklist = []
// returns true if valid
exports.validateAuthHash = function(dataString, hash) {
    if(!(hash && dataString))
        return false
    if(tokenBlacklist.indexOf(hash) !== -1)
          return false

    return keygrip.verify(dataString, hash)
}
exports.createAuthHash = function(dataString) {
    return keygrip.sign(dataString)
}
exports.blacklistAuthHash = function(hash) {
    tokenBlacklist.push(hash) // blacklist token
}

/*
// returns a future
exports.passwordHash = function(password) {
    var rounds = 10
    var seedLength = 30

    var hash = new Future
    bcrypt.genSalt(rounds, seedLength, function(err, salt) {
        if(err)
            result.throw(err)
        else {
            bcrypt.hash(password, salt, hash.resolver())
        }
    })

    return hash
}
// returns a future that throws an exception if the password doesn't match
exports.verifyPassword = function(password, storedHash) {
    return utils.futureWrap(bcrypt.compare)(password, storedHash)
}
*/

/* scrypt functions for when scrypt supports windows (or we decide windows doesn't matter)

// returns a future
exports.passwordHash = function(password) {
    var maxtime = 0.1 // in seconds
    var hash = new Future
    scrypt.passwordHash(password, maxtime, hash.resolver())
    return hash
}
// returns a future that throws an exception if the password doesn't match
exports.verifyPassword = function(password, storedHash) {
    var result = new Future
    scrypt.verifyHash(storedHash, password, result.resolver())
    return result
}
*/