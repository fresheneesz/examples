var Future = require('fibers/future'), wait = Future.wait
var ElasticSearchClient = require('elasticsearchclient')
//var mongo = require("mongoskin")
//var mongo = require("mongodb").MongoClient

var config = require('config')
var utils = require("utils")

var es = exports.es = {
    read: elasticsearchConnection(config.elasticsearch.read),
    write: elasticsearchConnection(config.elasticsearch.write)
}

function elasticsearchConnection(dbConfig) {
    return new ElasticSearchClient(dbConfig)
}


/*
// for not just use the same two connections for every request
// todo: pooling - does mongo need pooling?
// todo: also, figure out if requests are / can be sent asynchronously (ie multiple requests pending on same connection), otherwise will have to have a different connection for every request
exports.mongo = {
    read: mongoConnection(config.mongo.read),
    write: mongoConnection(config.mongo.write),
    id: mongo.id
}                                 `

function mongoConnection(dbConfig) {
    var url = dbConfig.location+'/'+dbConfig.db
    if(dbConfig.user)
        url = dbConfig.user+':'+dbConfig.pass+"@"+url

    return mongo.db(url, {journal: true}) // todo: should we do +"?auto_reconnect=true"
}
*/



/*



*/
/**
 * Creates a HashMap object with indexes as keys and their types as values
 * @param indexAndTypeArray array from which HashMap will be created
 * @return Map of index and types
 * @throws Exception
 *//*

public static Map<String, Collection<String>> getIndexMap(String[] indexAndTypeArray) throws Exception
{
    Map<String, Collection<String>> indexeMap = new HashMap<String, Collection<String>>();

    for (int i = 0; i < indexAndTypeArray.length; i++)
    {
        //Get an index and it's type
        String indexAndType = indexAndTypeArray[i];
        //Split the index and it's type
        String[] indexAndTypeSplitted = indexAndType.split("/");
        //Get the index name
        String index = indexAndTypeSplitted[0].trim();
        // Handle null
        if (index == null) throw new Exception("Can not read index in [" + indexAndType +
                "]. Check that mappings contains only indexname/mappingname elements.");

        // Add the mapping in the collection of its index
        if (!indexeMap.containsKey(index))
            indexeMap.put(index, new ArrayList<String>());

        if (indexAndTypeSplitted.length > 1) {
            String mapping = indexAndTypeSplitted[1].trim();
            indexeMap.get(index).add(mapping);
        }
    }

    return indexeMap;
}

*/
/**
 * Check if an index exists
 * @param index index name
 * @return true if index exists else false
 * @throws Exception
 *//*

public static boolean doesIndexExist(String index) throws Exception
{
    Client client = _getClient();

    return client
                .admin()
                .indices()
                .prepareExists(index)
                .execute()
                .actionGet()
                .isExists();
}

// checks to see if a document exists and returns approporiate boolean
public static boolean doesDocumentExist(String index, String type, String id) {
    Client client = _getClient();
    GetResponse response = client.prepareGet(index, type, id)
            .execute()
            .actionGet();
    if(response.toString().equals(null)){
        return false;
    } else {
        return true;
    }
}

*/
/**
 * Use this function to add a document in an ES index
 * @param indexName name of the index
 * @param typeName type name
 * @param docSource document source in json format
 *//*

public static String addDocument(String indexName, String typeName, String docSource)
{
    String responseId = null;
    Client client = _getClient();
    try {
        IndexResponse response = client.prepareIndex(indexName, typeName)
                .setSource(docSource)
                .setOperationThreaded(false)
                .setOpType(IndexRequest.OpType.CREATE)
                .execute()
                .actionGet();
        logger.info("Document successfully added in type "+typeName +". response id = "+response.getId());
        responseId = response.getId();

    } catch (ElasticSearchException e) {
        responseId = null;
        logger.error("Could not add the document in type "+typeName, e);
    }

    logger.info("Response id = "+responseId);
    return responseId;
}

public static String addDocumentWithId(String indexName, String typeName, XContentBuilder docSource, String id) throws Exception {
    Client client = _getClient();
    IndexResponse response = client.prepareIndex(indexName, typeName, id)
            .setSource(docSource)
            .setOperationThreaded(false)
            .setOpType(IndexRequest.OpType.CREATE)
            .execute()
            .actionGet();

    String returnedId = response.getId();
    if (!id.equals(returnedId)) {
        throw new Exception("Returned ID ("+ returnedId +") did not match ID intended (" + id + ")");
    }

    return returnedId;
}

public static String addExistingDocument(String index, String type, String id, XContentBuilder doc) throws Exception {
    Client client = _getClient();
    IndexResponse response = client.prepareIndex(index, type, id)
            .setSource(doc)
            .setOperationThreaded(false)
            .execute()
            .actionGet();

    String returnedId = response.getId();
    if (!id.equals(returnedId)) {
        throw new Exception("Returned ID ("+ returnedId +") did not match ID intended (" + id + ")");
    }

    return returnedId;
}

public static String addDocumentIfIDNotThere(String indexName, String typeName, XContentBuilder docSource, String id) throws Exception {
    Client client = _getClient();
    IndexResponse response = client.prepareIndex(indexName, typeName, id)
            .setOpType(IndexRequest.OpType.CREATE)
            .setOperationThreaded(false)
            .setSource(docSource)
            .execute()
            .actionGet();

    String returnedId = response.getId();
    if (!id.equals(returnedId)) {
        throw new Exception("Returned ID ("+ returnedId +") did not match ID intended (" + id + ")");
    }

    return returnedId;
}

public static String removeDocument (String index, String type, String id, Boolean isAsync) {
    Client client = _getClient();
    if(doesDocumentExist(index,type,id)) {
        DeleteResponse response = client.prepareDelete(index, type, id)
                .setOperationThreaded(isAsync)
                .execute()
                .actionGet();
        return response.toString();
    } else {
        return null;
    }


}

// if a document exists, this returns a GetResponse from the server
public static GetResponse getDocument(String index, String type, String id) throws Exception {
    Client client = _getClient();
    GetResponse response = client.prepareGet(index, type, id)
            .execute()
            .actionGet();
//        System.out.println(response.getSourceAsString());
    if(response.getSource() == null){
        throw new Exception("Document doesn't exist");
    }
    return response;
}

public static Map getDocumentNoException (String index, String type, String id) {
    Client client = _getClient();
    GetResponse response = client.prepareGet(index, type, id)
            .execute()
            .actionGet();
    return response.getSource();
}

*/
/**
 * Create an index
 * @param index Index name
 * @throws Exception
 *//*

public static void createIndex(String index) throws Exception
{
    Client client = _getClient();
    if (logger.isTraceEnabled()) logger.trace("createIndex("+index+")");
    if (logger.isDebugEnabled()) logger.debug("Index " + index + " doesn't exist. Creating it.");

    CreateIndexRequestBuilder cirb = client.admin().indices().prepareCreate(index);

    // If there are settings for this index, use it. If not, using Elasticsearch defaults.
    String source = readIndexSettings(index);
    if (source != null)
    {
        if (logger.isTraceEnabled()) logger.trace("Found settings for index "+index+" : " + source);
        cirb.setSettings(source);
    }

    CreateIndexResponse createIndexResponse = cirb.execute().actionGet();
    if (!createIndexResponse.isAcknowledged()) throw new Exception("Could not create index ["+index+"].");
    if (logger.isTraceEnabled()) logger.trace("/createIndex("+index+")");
}

*/
/**
 * Read settings for an index.
 * @param index Index name
 * @return Settings if exists. Null otherwise.
 * @throws Exception
 *//*

public static String readIndexSettings(String index) throws Exception
{
    return readFileInClasspath(Constant.CLASSPATH_ROOT + "/index/"+index+Constant.INDEX_SETTINGS_FILE_EXT);
}

*/
/**
 * Read a file in classpath and return its content
 * @param url File URL Example : /esconfig/type/_settings.json
 * @return File content or null if file doesn't exist
 * @throws Exception
 *//*

public static String readFileInClasspath(String url) throws Exception
{
    StringBuffer bufferJSON = new StringBuffer();
    try
    {
        InputStream ips = Configurator.class.getClassLoader().getResourceAsStream(url);
        InputStreamReader ipsr = new InputStreamReader(ips);
        BufferedReader br = new BufferedReader(ipsr);
        String line;

        while ((line=br.readLine())!=null)
        {
            bufferJSON.append(line);
        }
        br.close();
    }
    catch (Exception e)
    {
        e.printStackTrace();
        return null;
    }

    return bufferJSON.toString();
}

*/
/**
 * Merge index settings for existing index
 * @param index Index name
 * @throws Exception
 *//*

public static void mergeIndexSettings(String index) throws Exception
{
    Client client = _getClient();
    if (logger.isTraceEnabled()) logger.trace("mergeIndexSettings("+index+")");
    if (logger.isDebugEnabled()) logger.debug("Index " + index + " already exists. Trying to merge settings.");

    //checkClient();

    // Read index settings
    String source = readIndexSettings(index);

    if(source != null)
    {
        // Before merging, we have to close the index
        CloseIndexRequestBuilder cirb = client.admin().indices().prepareClose(index);
        CloseIndexResponse closeIndexResReturnObjectponse = cirb.execute().actionGet();
        if (!closeIndexResponse.isAcknowledged()) throw new Exception("Could not close index ["+index+"].");

        try
        {
            UpdateSettingsRequestBuilder usrb = client.admin().indices().prepareUpdateSettings(index);
            usrb.setSettings(source);

            usrb.execute().actionGet();

            OpenIndexRequestBuilder oirb = client.admin().indices().prepareOpen(index);
            OpenIndexResponse openIndexResponse = oirb.execute().actionGet();
            if (!openIndexResponse.isAcknowledged()) throw new Exception("Could not open index ["+index+"].");
        }

        catch(ElasticSearchIllegalArgumentException e)
        {
            throw new Exception(e.getMessage());

            Throwable t = new Exception("some message");
            t.initCause(e)
            throw t

        }

    }

    if (logger.isTraceEnabled()) logger.trace("/mergeIndexSettings("+index+")");
}

*/
/**
 * Define a type for a given index and if exists with its mapping definition, overwrite it.
 * @param index Index name
 * @param type Type name
 * @param isOverwrite Force rebuild the type : <b>Caution</b> : if true, all  datas for
 * this type will be erased. Use only for development or continuous integration
 * @param isMerge Merge existing mappings
 * @throws Exception
 *//*

public static void createMapping(String index, String type, boolean isOverwrite, boolean isMerge) throws Exception
{
    Client client = _getClient();
    if (logger.isTraceEnabled()) logger.trace("pushMapping("+index+","+type+","+isOverwrite+")");

    //checkClient();

    // If type already exists and if we are in force mode, we delete the type and its mapping
    if (isOverwrite && doesMappingExist(index, type)) {
        if (logger.isDebugEnabled()) logger.debug("Force remove old type and mapping ["+index+"]/["+type+"]");
        // Remove mapping and type in ElasticSearch !
        client.admin().indices()
            .prepareDeleteMapping(index)
            .setType(type)
            .execute().actionGet();
        // client.admin().cluster().prepareHealth().setWaitForYellowStatus().execute().actionGet();
    }

    // If type does not exist, we create it
    boolean mappingExist = doesMappingExist(index, type);
    if (isMerge || !mappingExist) {
        if (logger.isDebugEnabled()) {
            if (mappingExist) {
                logger.debug("Updating mapping ["+index+"]/["+type+"].");
            } else {
                logger.debug("Mapping ["+index+"]/["+type+"] doesn't exist. Creating it.");
            }
        }
        // Read the mapping json file if exists and use it
        String source = readMapping(index, type);
        if (source != null) {
            if (logger.isTraceEnabled()) logger.trace("Mapping for ["+index+"]/["+type+"]="+source);
            // Create type and mapping
            PutMappingResponse response = client.admin().indices()
                .preparePutMapping(index)
                .setType(type)
                .setSource(source)
                .execute().actionGet();
            if (!response.isAcknowledged()) {
                throw new Exception("Could not define mapping for type ["+index+"]/["+type+"].");
            } else {
                if (logger.isDebugEnabled()) {
                    if (mappingExist) {
                        logger.debug("Mapping definition for ["+index+"]/["+type+"] succesfully merged.");
                    } else {
                        logger.debug("Mapping definition for ["+index+"]/["+type+"] succesfully created.");
                    }
                }
            }
        } else {
            if (logger.isDebugEnabled()) logger.debug("No mapping definition for ["+index+"]/["+type+"]. Ignoring.");
        }
    } else {
        if (logger.isDebugEnabled()) logger.debug("Mapping ["+index+"]/["+type+"] already exists and mergeMapping is not set.");
    }
    if (logger.isTraceEnabled()) logger.trace("/pushMapping("+index+","+type+","+isOverwrite+")");
}

*/
/**
 * Check if a mapping already exists in an index
 * @param index Index name
 * @param type Mapping name
 * @return true if mapping exists else false
 *//*

public static boolean doesMappingExist(String index, String type)
{
    Client client = _getClient();
    IndexMetaData imd = null;
    try
    {

        ClusterState cs = client.admin().cluster().prepareState().setFilterIndices(index).execute().actionGet().getState();
        imd = cs.getMetaData().index(index);
    }
    catch (IndexMissingException e) {
        // If there is no index, there is no mapping either
    }
    catch(Exception e)
    {
        try {
            throw e;
        } catch (Exception e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }
    if (imd == null) return false;

    MappingMetaData mdd = imd.mapping(type);

    if (mdd != null) return true;
    return false;
}

*/
/**
 * Read the mapping for a type.<br>
 * @param index Index name
 * @param type Type name
 * @return Mapping if exists. Null otherwise.
 * @throws Exception
 *//*

private static String readMapping(String index, String type) throws Exception
{
    return readFileInClasspath(Constant.CLASSPATH_ROOT + "/index/" + index + "/" + type + Constant.JSONFILE_EXT);
}

*/
/**
 * Read property file and return an array of index and type e.g [live/user, live/code, summary/daily_user]
 * @return array of string
 *//*

public static String[] getIndexAndTypes()
{
    String indexAndTypeArray[] = null;
    Properties indexTypesProps = new Properties();
    try
    {
        //load a properties file from class path
        indexTypesProps.load(ESUtility.class.getClassLoader().getResourceAsStream("core_dev_index_types.properties"));
        indexAndTypeArray = indexTypesProps.getProperty("index_types").split(",");
    }
    catch (IOException ex)
    {
        indexAndTypeArray = null;
        ex.printStackTrace();
    }
    catch(Exception e)
    {
        indexAndTypeArray = null;
        e.printStackTrace();
    }

    return indexAndTypeArray;
}


public static SearchResponse search (QueryBuilder qb) {
    Client client = _getClient();
    SearchResponse sr = client.prepareSearch()
            .setQuery(qb)
            .setOperationThreading(SearchOperationThreading.NO_THREADS)
            .execute()
            .actionGet();

    return sr;
}

public static SearchResponse searchIndexType (String index, String type, QueryBuilder qb){
    Client client = _getClient();
    SearchResponse sr = client.prepareSearch(index)
            .setTypes(type)
            .setQuery(qb)
            .setOperationThreading(SearchOperationThreading.NO_THREADS)
            .execute()
            .actionGet();

    return sr;
}

public static UpdateResponse update (String index, String type, String id, String field, String[] params){
    Client client = _getClient();
     return client.prepareUpdate(index, type, id)
            .addScriptParam(field,params)
            .execute()
            .actionGet();
}

public static SearchHits searchHits (QueryBuilder qb) {
    return search(qb).getHits();
}

public static void deleteIndex (String index) {
    Client client = _getClient();
    client.admin().indices().delete(new DeleteIndexRequest(index)).actionGet();
}

public static void closeClient () {
    Client client = _getClient();
    client.close();
    _client = null;
}
*/
