var Fiber = require('fibers')
var Future = require('fibers/future'), wait = Future.wait
var mysql = require("mysql")
var mongo = require("mongoskin")
//var mongo = require("mongodb").MongoClient

var config = require('config')
var utils = require("utils")

// for not just use the same two connections for every request
// todo: pooling - does mongo need pooling?
// todo: also, figure out if requests are / can be sent asynchronously (ie multiple requests pending on same connection), otherwise will have to have a different connection for every request
exports.mongo = {
    read: mongoConnection(config.mongo.read),
    write: mongoConnection(config.mongo.write),
    id: mongo.id
}

// I don't think mysql can process requsts asynchronously, so use a new connection for every request
/*exports.mysql = {
    get read() { return mysqlConnection(config.mysql.read)},
    get write() { return mysqlConnection(config.mysql.write)}
}*/

function mysqlConnection(dbConfig) {
    var connection = mysql.createConnection({
	  host     : dbConfig.location,
	  user     : dbConfig.user,
	  password : dbConfig.password,
	  database : dbConfig.db
	})
    connection.connect()
    return connection
}
function mongoConnection(dbConfig) {
    var url = dbConfig.location+'/'+dbConfig.db
    if(dbConfig.user)
        url = dbConfig.user+':'+dbConfig.pass+"@"+url

    return mongo.db(url, {journal: true}) // todo: should we do +"?auto_reconnect=true"
}



/*
var query = exports.query = function(queryText,profile) {
	var future = new Future

	if (profile === undefined) {
		profile = defaultProfile
	}

	var pd = profiles[profile]

	var connection = mysql.createConnection({
	  host     : pd.host,
	  user     : pd.user,
	  password : pd.password,
	  database : pd.database
	})

	connection.connect()

	connection.query(queryText,function(err,rows) {
		if (err) {
			console.log(err + " while executing " + queryText)
            console.log(" \n"+(new Error()).stack)
		}
		future.return()
	})

	connection.end()

	return future
}
*/