var url = require('url')
var fs = require('fs')
var PathModule = require('path')
var querystring = require('querystring')
var Future = require('fibers/future')

var utils = require('utils')
var commands = require("commands")
var config = require("config")
var rootpath = require("rootpath")

var User = require("db/user")

module.exports = function(request,response) {
	try {
        var requestUrl = url.parse(request.url)
        var path = requestUrl.pathname
        var params = querystring.parse(requestUrl.query)
        var headers = request.headers // note: http lowers case for us so we don't have to worry about case-insensitivity
        var body = getRequestBody(request).wait()

        utils.log("path " + path)

        var explicitHandler = explicitRouting(path, headers) // case ins
        var resourcesHandler = resourcesRouting(path, headers)
        var handler = explicitHandler || resourcesHandler // explicit handler is default
        if(explicitHandler && resourcesHandler) {
            utils.log("ERROR: Explicit and implicit routes found for path "+path)
        }

        if(handler) {
            var result = handler(params, body.toString('utf8'))
        } else {
            var result = {code: 404, body: "You must be lost"}
        }

    } catch(e) {
        var result = {code: 500, body: "Sorry, something broke - we'll fix it soon!"}
        utils.log("Something borked: ",e)
    }

    writeResponse(result, response)
}

function explicitRouting(path, headers) {
    var parts = path.split('/')

    var image = parts[1] === 'image'
    var userImage = parts[1] === 'userimage'
    var favicon = path === '/favicon.ico'

    if(path === '/') {
        return require("front")

    } else if(path === '/login') {
        return jsonResponse(function(params, body) {
            var bodyParams = querystring.parse(body)
            return commands.login(bodyParams.username, bodyParams.password)
        })
    } else if(path === '/signUp') {
        return jsonResponse(function(params, body) {
            var bodyParams = querystring.parse(body);
            return commands.signUp(bodyParams.username, bodyParams.password, bodyParams.password2);
        })
    } else if(path === '/logout') {
        return jsonResponse(function(params, body, cookies) {
            return commands.logout(cookies.token)
        })


    } else if(path === '/createTransaction') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            var curUser = User.crackToken(bodyParams.token).id
            return commands.createTransaction(bodyParams.amount, User.makeById(curUser), bodyParams.otherPartyName, bodyParams.subject)
        })
    } else if(path === '/getTransactions') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            var curUserId = User.crackToken(bodyParams.token).id
            return commands.getTransactions(User.makeById(curUserId), User.makeById(bodyParams.userA), User.makeById(bodyParams.userB))
        })


    } else if(path === '/jslog') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            commands.jsLog(bodyParams.context, bodyParams.prio, bodyParams.msg, bodyParams.data)
        })
    }
}


// UTILITIES

function jsonResponse(getBody) {
    return function(params, body, cookies) {
        var result = getBody(params, body, cookies)
        if(result !== undefined)
            var body = JSON.stringify(result)
        else
            var body = ""

        return {body:body, headers:{'content-type':'text/json'}}
    }
}

// returns the request body as a Buffer
function getRequestBody(request, max) {
    var fdata = new Future
    var data = new Buffer(0)
    var error = undefined

    request.on('data', function(chunk) {
        data = Buffer.concat([data, chunk])

        if(max && data.length > max) {
            request.connection.destroy()
            error = new Error("maxDataExceeded")
        }
    })
    request.on('error', function(err) {
        error = err
        fdata.throw(new Error(err))
    })

    request.on('end', function() {
        if(error)
            fdata.throw(error)
        else
            fdata.return(data)
    })

    return fdata
}

function fileResponse(filepath, mimeType, gzip) {
    return fileResponseRaw(filepath, mimeType, gzip, function(){
        return fs.readFileSync(filepath)
    })
}

function fileResponseRaw(filepath, mimeType, gzip, getFile) {
    if(!gzip) gzip = true

    return function() {
        if(fs.existsSync(filepath))
            // todo: add 304 Not Modified response to enable browser caching
            // todo: look into the 'age' and 'expires' header - should we use them in place of max-age?
            return {body: getFile(), gzip:gzip,
                headers: {'content-type': mimeType, 'cache-control': 'public, max-age='+config.staticsCacheLength}}
        else {
            utils.log("File not found: "+filepath)
            return {code:404, body:''}
        }
    }
}

// loads handlers automatically from the resources folder
function resourcesRouting(path, headers) {
    var resourcePath = rootpath("resources/"+path+".js")
    if(fs.existsSync(resourcePath) && fs.lstatSync(resourcePath).isFile()) {
        return require(resourcePath)
    }
}

function writeResponse(result, response) {
    if(!result.code) result.code = 200
    if(result.headers === undefined) result.headers = {}
    if(!result.headers['content-type']) result.headers['content-type'] = 'text/plain'

    /* todo: gzip
    var encodings = headers['Accept-Encoding'].split(',').map(function(v) {
        return v.trim().toLowerCase()
    })
    if(gzip && encodings.has('gzip')) {
        result.headers = {'Content-Encoding':'gzip'}
        result.body =
    }
    */

    result.headers['content-length'] = result.body.length

	response.writeHead(result.code, result.headers)
    if(result.body)
        response.write(result.body)
    response.end()
}

