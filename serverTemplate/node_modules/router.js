var url = require('url')
var fs = require('fs')
var PathModule = require('path')
var querystring = require('querystring')
var zlib = require("zlib")
var Future = require('fibers/future')
var cookie = require('cookie')
var mmm = require('mmmagic'), Magic = new mmm.Magic(mmm.MAGIC_MIME_TYPE)
var less = require('less').Parser

var utils = require('utils')
var database = require("database")
var commands = require("commands")
var config = require("config")
var rootpath = require("rootpath")

var User = require("db/user")

module.exports = function(request,response) {
	try {
        var requestUrl = url.parse(request.url)
        var path = requestUrl.pathname
        var params = querystring.parse(requestUrl.query)
        var headers = request.headers // note: http lowers case for us so we don't have to worry about case-insensitivity
        var body = getRequestBody(request).wait()

        utils.log("path " + path)

        var explicitHandler = explicitRouting(path, headers) // case ins
        var resourcesHandler = resourcesRouting(path, headers)
        var handler = explicitHandler || resourcesHandler // explicit handler is default
        if(explicitHandler && resourcesHandler) {
            utils.log("ERROR: Explicit and implicit routes found for path "+path)
        }

        if(handler) {
            var result = handler(params, body.toString('utf8'), getCookies(headers))
        } else {
            var result = {code: 404, body: "You must be lost"}
        }

    } catch(e) {
        var result = {code: 500, body: "Sorry, something broke - we'll fix it soon!"}
        utils.log("Something borked: ",e)
    }

    writeResponse(result, response)
}

function explicitRouting(path, headers) {
    var parts = path.split('/')

    var image = parts[1] === 'image'
    var userImage = parts[1] === 'userimage'
    var favicon = path === '/favicon.ico'

    if(path === '/') {
        return require("front")


    } else if(path === '/favicon.ico') {
        return imageResponse(utils.staticUrl('image/favicon.ico'))

    } else if(parts[1] === 'static') {
        var filepath = rootpath('./'+path) // the dot makes the path relative

        if(parts[2] === 'image') {
            return imageResponse(filepath)
        } else if(parts[2] === 'js') {
            if(parts[3] === 'cookies.min.js') { // installed via npm
                return fileResponse(rootpath('../node_modules/cookies-js/src/cookies.min.js'), 'text/javascript')
            } else {
                return fileResponse(filepath, 'text/javascript')
            }

        } else if(parts[2] === 'style') {
            if(PathModule.extname(filepath) === '.less')
                return lessResponse(filepath)
            else
                return fileResponse(filepath, 'text/css')
        } else {
           return fileResponse(filepath, 'text/plain')
        }
    } else if(parts[1] === 'userfile') {
        var filepath = rootpath('../userfile/image/'+parts[3])
        if(parts[2] === 'image') {
            return imageResponse(filepath)
        } else {
            return fileResponse(filepath, 'text/plain')
        }


    } else if(path === '/login') {
        return jsonResponse(function(params, body) {
            var bodyParams = querystring.parse(body)
            return commands.login(bodyParams.username, bodyParams.password)
        })
    } else if(path === '/signUp') {
        return jsonResponse(function(params, body) {
            var bodyParams = querystring.parse(body);
            return commands.signUp(bodyParams.username, bodyParams.password, bodyParams.password2);
        })
    } else if(path === '/logout') {
        return jsonResponse(function(params, body, cookies) {
            return commands.logout(cookies.token)
        })


    } else if(path === '/createTransaction') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            var curUser = User.crackToken(bodyParams.token).id
            return commands.createTransaction(bodyParams.amount, User.makeById(curUser), bodyParams.otherPartyName, bodyParams.subject)
        })
    } else if(path === '/getTransactions') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            var curUserId = User.crackToken(bodyParams.token).id
            return commands.getTransactions(User.makeById(curUserId), User.makeById(bodyParams.userA), User.makeById(bodyParams.userB))
        })


    } else if(path === '/jslog') {
        return jsonResponse(function(params, body, cookies) {
            var bodyParams = querystring.parse(body)
            commands.jsLog(bodyParams.context, bodyParams.prio, bodyParams.msg, bodyParams.data)
        })
    }
}


// UTILITIES


function getCookies(headers) {
    if(headers.cookie === undefined)
        return {}
    else
        return cookie.parse(headers.cookie)
}

function jsonResponse(getBody) {
    return function(params, body, cookies) {
        var result = getBody(params, body, cookies)
        if(result !== undefined)
            var body = JSON.stringify(result)
        else
            var body = ""

        return {body:body, headers:{'content-type':'text/json'}}
    }
}

function lessResponse(filepath) {
    return fileResponseRaw(filepath, "text/css", true, function(){
        // compile less if necessary
            // (old) to do: is the compiled file older than the source file?
            // todo: actually forget that, just generate it on the fly every time and rely on CDN for caching

            // if so recompile
        var parser = new less({
            filename: filepath, // Specify a filename, for better error messages
            optimization: 1    // http://onedayitwillmake.com/blog/2013/03/compiling-less-from-a-node-js-script/ - "optimization level, higher is better but more volatile - 1 is a good value"
        })

        var lessTree = new Future
        parser.parse(fs.readFileSync(filepath).toString(), function(err, tree) {
            if(err) lessTree.throw(new Error(JSON.stringify(err)))
            else lessTree.return(tree)
        })
        var tree = lessTree.wait()
        try {
            var compiledCss = tree.toCSS({compress:true, yuicompress:true}) // Minify CSS output
        } catch(e) {
            throw new Error(JSON.stringify(e))
        }

        // todo: store the compiled output in a file

        // return that compiled file
        return compiledCss
    })
}

// returns the request body as a Buffer
function getRequestBody(request, max) {
    var fdata = new Future
    var data = new Buffer(0)
    var error = undefined

    request.on('data', function(chunk) {
        data = Buffer.concat([data, chunk])

        if(max && data.length > max) {
            request.connection.destroy()
            error = new Error("maxDataExceeded")
        }
    })
    request.on('error', function(err) {
        error = err
        fdata.throw(new Error(err))
    })

    request.on('end', function() {
        if(error)
            fdata.throw(error)
        else
            fdata.return(data)
    })

    return fdata
}

function imageResponse(filepath) {
    var type = new Future
    Magic.detectFile(filepath, type.resolver())

    return fileResponse(filepath, type.wait(), false)
}

function fileResponse(filepath, mimeType, gzip) {
    return fileResponseRaw(filepath, mimeType, gzip, function(){
        return fs.readFileSync(filepath)
    })
}

function fileResponseRaw(filepath, mimeType, gzip, getFile) {
    if(!gzip) gzip = true

    return function() {
        if(fs.existsSync(filepath))
            // todo: add 304 Not Modified response to enable browser caching
            // todo: look into the 'age' and 'expires' header - should we use them in place of max-age?
            return {body: getFile(), gzip:gzip,
                headers: {'content-type': mimeType, 'cache-control': 'public, max-age='+config.staticsCacheLength}}
        else {
            utils.log("File not found: "+filepath)
            return {code:404, body:''}
        }
    }
}

// loads handlers automatically from the resources folder
function resourcesRouting(path, headers) {
    var resourcePath = rootpath("resources/"+path+".js")
    if(fs.existsSync(resourcePath) && fs.lstatSync(resourcePath).isFile()) {
        return require(resourcePath)
    }
}

function writeResponse(result, response) {
    if(!result.code) result.code = 200
    if(result.headers === undefined) result.headers = {}
    if(!result.headers['content-type']) result.headers['content-type'] = 'text/plain'

    /* todo: gzip
    var encodings = headers['Accept-Encoding'].split(',').map(function(v) {
        return v.trim().toLowerCase()
    })
    if(gzip && encodings.has('gzip')) {
        result.headers = {'Content-Encoding':'gzip'}
        result.body =
    }
    */

    result.headers['content-length'] = result.body.length

	response.writeHead(result.code, result.headers)
    if(result.body)
        response.write(result.body)
    response.end()
}

