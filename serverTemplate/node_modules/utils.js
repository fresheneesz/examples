require('bt/sugarwrap')
var utils = require('bt/utils')
var rootpath = require('rootpath')
var Future = require('fibers/future')
var moment = require("moment")
var Validator = require('validator').Validator
var domain = require('domain').create

// aggregation of utility functions
utils.merge(module.exports, require('util'))
utils.merge(module.exports, utils)
utils.merge(module.exports, require('./webutil'))

exports.staticUrl = function(relativeUrl) {
    return rootpath('static/'+relativeUrl)
}

exports.getMachineName = function() {
    return require('os').hostname()
}

exports.getAddresses = function() {
    var interfaces = require('os').networkInterfaces()
    var addresses = []
    for (k in interfaces) {
        for (k2 in interfaces[k]) {
            var address = interfaces[k][k2]
            if (address.family === 'IPv4' && !address.internal) {
                addresses.push(address.address)
            }
        }
    }

    return addresses
}

// a standard time format for internal perfund things
exports.timeFormat = function(date) {
    return moment(date).format('YYYY-MM-DD HH-mm-ss')
}

// returns a true/false validation (as opposed to Validator's normal exception throw)
exports.check = function(text) {
    var v = new Validator()
    v.error = function () {
        return false;
    };

    return v.check(text)
}

// asynchronous try catch using domains
exports.async = function(options) {
    // basically does the same thing as process.on('uncaughtException') but much more flexibly
    // see http://nodejs.org/api/domain.html
    var d = domain()
    d.on('error', function(err) {
        options.catch(err)
    })

    d.run(function() {
        options.try()
    })
}